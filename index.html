<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
      <title>Realtime Extensions for Go</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
      <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Go<sup>RT</sup></h1>
      <h2 class="project-tagline">Realtime extensions for the Go programming language</h2>
        <h2 class="project-progress">Completion Progress</h2>
        <progress class="project-progressbar" value="22" max="100"></progress>
        <br>
        <a href="https://github.com/RedShamilton/go" class="btn">View on GitHub</a>
    </section>

    <section class="main-content">
        <h2>
            <a id="motivation" class="anchor" href="#motivation"
               aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span>
            </a>
            Motivation
        </h2>

        <p>
            The effort to develop Go<sup>RT</sup> was stimulated by the original task from the project
            <a href="https://sites.google.com/site/roselineproject/"><span class="roseline">Roseline</span></a> as a
            requirement for a high-level programming language that exposes the <abbr title="Quality of Time">QoT</abbr>
            characteristics to the application programmer using a modern language. The Go programming language was
            chosen
            for the abstraction of parallelism/concurrency that it utilizes, Goroutines and Channels, based upon the
            <abbr title="Communicating Sequential Processes">CSP</abbr> work done by C.A.R. Hoare.
        </p>

        <p>
            The task of writing the realtime extensions for the Go programming language came as a natural progression
            of defining what a language should provide in the framework of <span class="roseline">Roseline</span>. In a
            framework that strives to expose as much details about time to the application programmer naturally lends
            itself to realtime applications and as such the language was deemed necessary to provide realtime
            facilities.
        </p>

        <p>
            These realtime facilities that Go<sup>RT</sup> provides have two distinct advantages over using an
            <abbr title="Realtime Operating System">RTOS</abbr>. The first advantage is one of portability; that is, an
            application can be written in Go<sup>RT</sup> and any platform in the future that supports Go<sup>RT</sup>
            can run this application without modification. The second advantage is that the programmer can develop their
            application on the latest mainline version of the Linux kernel with PREEMPT-RT enabled whereas many of the
            realtime Linux variants are often several versions behind and due to the nature of their modifications will
            likely never be merged into the main development line. Another current advantage that likely will change in
            the near future is that a realtime application developed in Go<sup>RT</sup> can achieve better performance
            with respect to scheduling latency than the same application can using kernel threads due to extremely low
            scheduling latency that is seen in user-level threads packages (what Goroutines essentially boil down too).
        </p>

      <h2>
        <a id="current-progress" class="anchor" href="#current-progress" aria-hidden="true"><span aria-hidden="true"
                                                                                                  class="octicon octicon-link"></span></a>
          Current Progress
      </h2>

        <p>
            We are currently porting the work that Zhou Fang did previously on Go 1.4 to Go 1.7. This involves a fairly
            substantial rewrite as Go has since switched from compiler being written in C and Go to being entirely
            written in Go. The previous work did not have modifications to the compiler's parser and code generation so
            this work is new.
        </p>

        <ul style="list-style-type:none">
            <li>&#x2611; Modify Compiler
                <ul style="list-style-type:none">
                    <li>&#x2611; Modify parser to recognize <code>go (t,d,c)</code> variant of the <code>go</code>
                        operator
                    </li>
                    <li>&#x2611; Modify AST to represent <code>go (t,d,c)</code> variant of the <code>go</code> operator
                    </li>
                    <li>&#x2611; Modify <code>type g struct</code> to hold t,d, and c parameters</li>
                    <li>&#x2611; Modify code generation for setting t,d, and c parameters when <code>go (t,d,c)</code>
                        is invoked
                    </li>
                </ul>
            </li>
            <li>&#x2610; Modify Scheduler
                <ul style="list-style-type:none">
                    <li>&#x2611; Write EDF based next goroutine selection</li>
                    <li>&#x2610; Remove work stealing from realtime scheduling</li>
                    <li>&#x2610; Remove other throughput features from realtime scheduling</li>
                </ul>
            </li>
            <li>&#x2610; Modify Channels</li>
            <li>&#x2610; Modify Memory Manager</li>
            <li>&#x2610; Write <code>realtime</code> package
                <ul style="list-style-type:none">
                    <li>&#x2610; Write <code>setup</code> function to handle preallocating memory, setting interrupt and
                        CPU affinities, and etc
                    </li>
                    <li>&#x2610; Write profiling function to monitor performance while executing</li>
                </ul>
            </li>
        </ul>

      <h2>
          <a id="schedule-latency-analysis" class="anchor" href="#schedule-latency-analysis"
             aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          Scheduling Latency Analysis
      </h2>

        <p>
            One of the most important factors and considerations in determining if a realtime platform can adequately
            perform a real-time application is scheduling latency. To obtain these figures we use the de facto standard
            utility for Linux, <a href="https://rt.wiki.kernel.org/index.php/Cyclictest"><code>cyclictest</code></a>,
            for obtaining scheduling latencies. The <code>cyclictest</code> utility measures the latency from when a
            timer expires until when the thread that set the timer is executed. A modified version of this utility is in
            the works to measure the latency from when a GPIO triggered interrupt is fired till when the servicing
            thread (not the ISR) is executing.
        </p>

        <h3>
            <a id="test-platform" class="anchor" href="#test-platform" aria-hidden="true"><span
                    aria-hidden="true" class="octicon octicon-link"></span></a>
            Test Platform
        </h3>

        The test platform used for these benchmarks is the reference <span class="roseline">Roseline</span> system,
        the BeagleBone Black (BBB) embedded development board by Texas Instruments.

        <h4>Hardware Configuration</h4>

        <strong>Revision:</strong> C<br>
        <strong>Processor:</strong> Texas Instruments Sitara XAM3359AZCZ100 Cortex A8 1GHz<br>
        <strong>Memory:</strong> 512MB DDR3L 800MHz<br>
        <strong>Storage:</strong> 64 GB μSD<br>
        <strong>Power:</strong> Dedicated External 5v PS

        <h4>Software Configuration</h4>

        <strong>U-Boot:</strong> 2016.09-rc1-00245-gad6a303<br>
        <strong>Kernel:</strong> 4.4.6-bone-rt-r7 PREEMPT RT<br>
        <strong>Device Tree:</strong> am335x-boneblack-overlay.dtb (HDMI Audio/Video/eMMC disabled)<br>
        <strong>PM:</strong> CPU governor is disable and CPU runs at max frequency of 1 GHz<br>
        <strong>Services:</strong> systemd (/sbin/init), systemd-journald, systemd-logind<br>
        <strong>Access:</strong> serial port

      <h3>
        <a id="linux-with-preempt-rt-patch" class="anchor" href="#linux-with-preempt-rt-patch" aria-hidden="true"><span
                aria-hidden="true" class="octicon octicon-link"></span></a>
          Linux with PREEMPT-RT Patch
      </h3>

        <p>
            The results below show that the best case scenario is about a 7 μs latency. The value of best case scenario
            can be factored into the period of a given task to account for the scheduling latency, e.g. a task with a
            period of 1000 μs would be set to 993 μs. Then the worst-case scenario - the best-case scenario (62 - 11 =
            51 μs)
            represents the single-sided scheduling jitter that must be taken into account. If this jitter is tolerable
            for the application, it can be added onto the worst-case execution time of a task to account for it in
            various scheduling algorithms such as cyclic executive, EDF, and etc... It's worth noting that the
            worst-case
            value of 62 μs also drives what the minimum period of a task could be on this platform. There are other ways
            of incorporating these numbers into the various parameters of a task and it is up to the developer how they
            choose to treat these numbers and account for them.
        </p>

        <p>
            The results for SCHED_NORM were included for completeness but it can be seen that these values are orders of
            magnitude worse than SCHED_FIFO. Tasks utilizing the SCHED_NORM scheduling class are lower priority than any
            SCHED_FIFO task regardless of priority and typically are used for background tasks, system services and
            such.
        </p>

      <div class="highlight highlight-source-shell">
        <pre>
          <span class="pl-c"># The test is run 10 times in a loop to obtain more data points and verify</span>
          <span class="pl-c"># repeatable results</span>
          <span class="pl-c">#</span>
          <span class="pl-c"># -l 100000       - runs the test 100,000 times</span>
          <span class="pl-c"># -t              - schedules 1 thread per CPU</span>
          <span class="pl-c"># -p 99           - sets the thread priority to 99</span>
          <span class="pl-c"># -n              - uses clock_nanosleep</span>
          <span class="pl-c"># -q              - suppresses output until test is completed</span>
          <span class="pl-c"># --policy=normal - uses SCHED_NORMAL instead of the default SHED_FIFO</span>
          <span class="pl-c">#                   scheduler class for the test</span>

          <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">'</span>---------    cyclictest -t -p 99 -n -l 100000 -q    -----------<span
                class="pl-pds">'</span></span>
          <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">in</span> <span
                class="pl-s"><span class="pl-pds">`</span>seq 1 10<span class="pl-pds">`</span></span><span
                class="pl-k">;</span> <span class="pl-k">do</span> cyclictest -t -p 99 -n -l 100000 -q<span
                class="pl-k">;</span> <span class="pl-k">done</span>
          <span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">'</span>---------    cyclictest -t --policy=normal -n -l 100000 -q    -----------<span
                class="pl-pds">'</span></span>
          <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">in</span> <span
                class="pl-s"><span class="pl-pds">`</span>seq 1 10<span class="pl-pds">`</span></span><span
                class="pl-k">;</span> <span class="pl-k">do</span> cyclictest -t --policy=normal -n -l 100000 -q<span
                class="pl-k">;</span> <span class="pl-k">done</span>
        </pre>
      </div>

      <pre>
        <code>
          Output of the above test script

          ---------    cyclictest -t -p 99 -n -l 100000 -q    -----------
          T: 0 (17266) P:99 I:1000 C: 100000 Min:   8 Act:   14 Avg:   11 Max:   55
          T: 0 (17268) P:99 I:1000 C: 100000 Min:   8 Act:   10 Avg:   11 Max:   62
          T: 0 (17270) P:99 I:1000 C: 100000 Min:   7 Act:   10 Avg:   11 Max:   56
          T: 0 (17272) P:99 I:1000 C: 100000 Min:   7 Act:   10 Avg:   11 Max:   56
          T: 0 (17274) P:99 I:1000 C: 100000 Min:   7 Act:   14 Avg:   11 Max:   63
          T: 0 (17276) P:99 I:1000 C: 100000 Min:   8 Act:   10 Avg:   11 Max:   61
          T: 0 (17278) P:99 I:1000 C: 100000 Min:   7 Act:   10 Avg:   11 Max:   54
          T: 0 (17281) P:99 I:1000 C: 100000 Min:   7 Act:   10 Avg:   11 Max:   57
          T: 0 (17283) P:99 I:1000 C: 100000 Min:   7 Act:   10 Avg:   11 Max:   53
          T: 0 (17285) P:99 I:1000 C: 100000 Min:   7 Act:   11 Avg:   11 Max:   49
          ---------    cyclictest -t --policy=normal -n -l 100000 -q    -----------
          T: 0 ( 1910) P: 0 I:1000 C: 100000 Min:   17 Act:  61 Avg:   61 Max:   951
          T: 0 ( 1912) P: 0 I:1000 C: 100000 Min:   16 Act:  61 Avg:   61 Max:   805
          T: 0 ( 1914) P: 0 I:1000 C: 100000 Min:   17 Act:  61 Avg:   61 Max:  1691
          T: 0 ( 1916) P: 0 I:1000 C: 100000 Min:   17 Act:  61 Avg:   61 Max:   928
          T: 0 ( 1918) P: 0 I:1000 C: 100000 Min:   16 Act:  61 Avg:   61 Max:  1497
          T: 0 ( 1920) P: 0 I:1000 C: 100000 Min:   16 Act:  61 Avg:   61 Max:  1305
          T: 0 ( 1923) P: 0 I:1000 C: 100000 Min:   17 Act:  61 Avg:   61 Max:  5338
          T: 0 ( 1925) P: 0 I:1000 C: 100000 Min:   16 Act:  61 Avg:   61 Max:  1486
          T: 0 ( 1927) P: 0 I:1000 C: 100000 Min:   17 Act:  63 Avg:   61 Max:  1530
          T: 0 ( 1929) P: 0 I:1000 C: 100000 Min:   17 Act:  61 Avg:   61 Max:  1018
        </code>
      </pre>

      <figure>
          <figcaption>Figure 1: Scheduling Latency Histogram for SCHED_FIFO</figcaption>
          <img src="images/hist-fifo.svg" alt="Histogram for SCHED_FIFO">

          <figcaption>Figure 2: Scheduling Latency Histogram for SCHED_NORM</figcaption>
          <img src="images/hist-norm.svg" alt="Histogram for SCHED_NORM">
      </figure>

      <h3>
          <a id="go-language" class="anchor" href="#go-language" aria-hidden="true"><span aria-hidden="true"
                                                                                          class="octicon octicon-link"></span></a>
          Go Language
      </h3>

        <p>
            A rewrite of <code>cyclictest</code> called <a href="https://github.com/RedShamilton/cyclictest-go"><code>cyclictest-go</code></a>
            is used here to obtain the results. This version uses a newly added method to the <code>time</code> package
            called <code>time.WaitUntil(t Time)</code>. This new method waits until a specific period in time compared
            to <code>time.Sleep(d Duration)</code> which only sleeps for a relative amount of time from invocation. This
            version is still a work in progress and has some known issues as noted in the <code>README</code> file.
        </p>

        <p>
            It can be seen from the output below that the best and average cases are better than those observed in the
            C version of <code>cyclictest</code>; however, the worst case tends to be slightly worse.
        </p>

        <pre>
            <code>
                root@beaglebone:~# cyclictest-go -t 1 -l 10000 -p 99
                T:  0 P:99 I: 1ms C:   10000 Min:     1.319µs Act:     2.027µs Avg:    12.709µs Max: 81.485µs
            </code>
        </pre>

        <figure>
            <figcaption>Figure 3: Scheduling Latency Histogram for Go</figcaption>
            <img src="images/hist-go.svg" alt="Histogram for Go">
        </figure>

      <h3>
        <a id="go-language-with-realtime-extensions" class="anchor" href="#go-language-with-realtime-extensions"
           aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>

          Go Language with Realtime Extensions
      </h3>

        <p>Waiting to complete Go<sup>RT</sup></p>

        <h2>
            <a id="definitions" class="anchor" href="#definitions" aria-hidden="true"><span aria-hidden="true"
                                                                                            class="octicon octicon-link"></span></a>
            Definitions
        </h2>

        <dl>
            <dt>Resolution:</dt>
            <dd>The smallest representable unit of a measurement</dd>
            <dt>Accuracy:</dt>
            <dd>The smallest repeatable unit of measurement</dd>
            <dt>Latency:</dt>
            <dd>The time elapsed from some time T when an event has actually occurred till
                when it is acknowledge as having occurred
            </dd>
            <dt>Jitter:</dt>
            <dd>The deviation from true periodicity of a presumed periodic event</dd>
        </dl>

        <h2>
            <a id="references" class="anchor" href="#references" aria-hidden="true"><span aria-hidden="true"
                                                                                          class="octicon octicon-link"></span></a>
            References
        </h2>

        <ol>
            <li>
                <cite>Communicating sequential processes</cite>, C.A.R. Hoare, Communications of the ACM, vol. 21, no.
                8, pp. 666-677, 1978.
            </li>
            <li>
                <cite>A Comparison of Scheduling Latency in Linux, PREEMPT RT, and LITMUS<sup>RT</sup></cite>, Felipe
                Cerqueira and Bjorn Brandenburg, Max Planck Institute for Software Systems (MPI-SWS)
            </li>
            <li>
                <cite>Using and Understanding the Real-Time Cyclictest Benchmark</cite>, Frank Rowand, Sony Mobile
                Communications, Oct 2013, http://events.linuxfoundation.org/sites/events/files/slides/cyclictest.pdf
            </li>
        </ol>

        <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/RedShamilton/go">Go<sup>RT</sup></a> is maintained by <a
                href="http://acsweb.ucsd.edu/~skhamilt/">Sean Hamilton</a>, Zhou Fang, and Dr. Rajesh Gupta.</span>
      </footer>

    </section>
  </body>
</html>
